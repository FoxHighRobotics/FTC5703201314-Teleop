#pragma config(Hubs,  S3, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S4, HTServo,  none,     none,     none)
#pragma config(Sensor, S1,     sensorIR,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S2,     sensorSonar,    sensorSONAR)
#pragma config(Sensor, S3,     ,               sensorI2CMuxController)
#pragma config(Sensor, S4,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S3_C1_1,     motorDriveRight, tmotorTetrix, PIDControl, reversed)
#pragma config(Motor,  mtr_S3_C1_2,     motorDriveLeft, tmotorTetrix, PIDControl)
#pragma config(Motor,  mtr_S3_C2_1,     motorElevator, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C2_2,     motorArmPitch, tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S4_C1_1,    servoArmGripper,      tServoContinuousRotation)
#pragma config(Servo,  srvo_S4_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S4_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// The Doppler Effect 2013-2014
// Teleop V3 Source
// Designed for FTC Block Party 2013-2014

/* -------------------------------------------------- */

#include "TeleopV3.h"
#include "JoystickDriver.c"

volatile int maxPowerDrive;
volatile int maxPowerArmPitch;

volatile float motorDriveLeftPower;
volatile float motorDriveRightPower;

volatile float motorArmPitchPower;
volatile float motorElevatorPower;

volatile int gripperState;

volatile int precisionMode1;
volatile int precisionMode2;

void initialize() {
	// Initialize max motor powers
	maxPowerDrive    = DRIVE_POWER_MAXIMUM;
	maxPowerArmPitch = ARM_PITCH_POWER_MAXIMUM;

	// Initialize drive powers
	motorDriveLeftPower  = 0;
	motorDriveRightPower = 0;

	// Initialize arm pitch and elevator powers
	motorArmPitchPower = 0;
	motorElevatorPower = 0;

	// Initialize gripper state
	gripperState = 0;

	// Initialize precision mode states
	precisionMode1 = 0;
	precisionMode2 = 0;

	// Motor speed regulation
	nMotorPIDSpeedCtrl[motorDriveLeft]  = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorDriveRight] = mtrSpeedReg;

	// Reset encoder values
	//nMotorEncoder[motorDriveLeft]  = 0;
	//nMotorEncoder[motorDriveRight] = 0;

	// Increase precision with PWM off-duty braking
	bFloatDuringInactiveMotorPWM = false;
}

task main() {
	// Wait for the FCS start signal
	waitForStart();

	// Initialize
	initialize();

	// Start controller task
	StartTask(controller);

	while (true) {
		// Set drive motor powers
		motor[motorDriveLeft]  = (int) motorDriveLeftPower;
		motor[motorDriveRight] = (int) motorDriveRightPower;

		// Set arm and elevator motor powers
		motor[motorArmPitch] = (int) motorArmPitchPower;
		motor[motorElevator] = (int) motorElevatorPower;

		// Handle gripper state
		switch (gripperState) {
			case 0: // Idle
				servo[servoArmGripper] = SERVO_ARM_GRIPPER_STATE_IDLE;
				break;
			case 1: // Opening
				servo[servoArmGripper] = SERVO_ARM_GRIPPER_STATE_OPENING;
				break;
			case 2: // Closing
				servo[servoArmGripper] = SERVO_ARM_GRIPPER_STATE_CLOSING;
				break;
		}
	}
}

task controller() {
	while (true) {
		// Poll controller data
		getJoystickSettings(joystick);

		// Precision mode toggle on controller 1
		if (joy1Btn(BUTTON_PRECISION_MODE_1) == 0 && precisionMode1 == 2) { // Need to engage
			precisionMode1 = 1;
		}
		if (joy1Btn(BUTTON_PRECISION_MODE_1) == 0 && precisionMode1 == 3) { // Need to disengage
			precisionMode1 = 0;
		}
		if (joy1Btn(BUTTON_PRECISION_MODE_1) == 1 && precisionMode1 == 0) { // About to engage
			precisionMode1 = 2;
		}
		if (joy1Btn(BUTTON_PRECISION_MODE_1) == 1 && precisionMode1 == 1) { // About to disengage
			precisionMode1 = 3;
		}

		// Precision mode toggle on controller 2
		if (joy2Btn(BUTTON_PRECISION_MODE_2) == 0 && precisionMode2 == 2) { // Need to engage
			precisionMode2 = 1;
		}
		if (joy2Btn(BUTTON_PRECISION_MODE_2) == 0 && precisionMode2 == 3) { // Need to disengage
			precisionMode2 = 0;
		}
		if (joy2Btn(BUTTON_PRECISION_MODE_2) == 1 && precisionMode2 == 0) { // About to engage
			precisionMode2 = 2;
		}
		if (joy2Btn(BUTTON_PRECISION_MODE_2) == 1 && precisionMode2 == 1) { // About to disengage
			precisionMode2 = 3;
		}

		// Calculate maximum motor powers
		maxPowerDrive    = (precisionMode1 == 1 ? DRIVE_POWER_PRECISE : DRIVE_POWER_MAXIMUM);
		maxPowerArmPitch = (precisionMode2 == 1 ? ARM_PITCH_POWER_PRECISE : ARM_PITCH_POWER_MAXIMUM);

		// Derive drive powers
		if (abs(joystick.joy1_y1) > JOYSTICK_DEADBAND_THRESHOLD) {
			motorDriveLeftPower = ((float) joystick.joy1_y1/-128.0)*maxPowerDrive;
		} else {
			motorDriveLeftPower = 0;
		}
		if (abs(joystick.joy1_y2) > JOYSTICK_DEADBAND_THRESHOLD) {
			motorDriveRightPower = ((float) joystick.joy1_y2/-128.0)*maxPowerDrive;
		} else {
			motorDriveRightPower = 0;
		}

		// Derive elevator power
		if (joy2Btn(BUTTON_ELEVATOR_UP) == 1) {
			motorElevatorPower = 100;
		} else if (joy2Btn(BUTTON_ELEVATOR_DOWN) == 1) {
			motorElevatorPower = -100;
		} else {
			motorElevatorPower = 0;
		}

		// Derive arm pitch power
		if (abs(joystick.joy2_y1) > JOYSTICK_DEADBAND_THRESHOLD) {
			motorArmPitchPower = ((float) joystick.joy2_y1/-128.0)*maxPowerArmPitch;
		} else {
			motorArmPitchPower = 0;
		}

		// Derive the gripper state
		if (joy2Btn(BUTTON_GRIPPER_OPEN) == 1) {
			gripperState = 1;
		} else if (joy2Btn(BUTTON_GRIPPER_CLOSE) == 1) {
			gripperState = 2;
		} else {
			gripperState = 0;
		}
	}
}
